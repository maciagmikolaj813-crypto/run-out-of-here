<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Run Out Of Here! INDEV</title>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Consolas', monospace; color: #fff; }
        #menu { position: fixed; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; background: #000; z-index: 100; border: 5px solid #0f0; margin: 10px; }
        .box { border: 1px solid #0f0; padding: 20px; width: 400px; background: #111; text-align: center; }
        #hud { position: fixed; top: 20px; left: 20px; z-index: 10; display: none; background: rgba(0,0,0,0.8); padding: 15px; border: 1px solid #0f0; }
        #prompt { position: fixed; bottom: 30%; left: 50%; transform: translateX(-50%); font-size: 24px; color: #0f0; display: none; }
        #crosshair { position: fixed; top: 50%; left: 50%; width: 10px; height: 10px; border: 2px solid #0f0; transform: translate(-50%, -50%); border-radius: 50%; z-index: 5; display: none; }
        #status { font-size: 10px; color: #555; margin-top: 10px; }
        button { background: #0f0; color: #000; border: none; padding: 12px; font-weight: bold; cursor: pointer; width: 100%; margin: 5px 0; }
        input { width: 100%; padding: 10px; margin: 5px 0; background: #000; color: #0f0; border: 1px solid #0f0; box-sizing: border-box; }
    </style>
</head>
<body>

    <div id="crosshair"></div>
    <div id="prompt">NACIŚNIJ [E]</div>

    <div id="menu">
        <h1>Run Out Of Here! INDEV</h1>
        <div class="box">
            <button onclick="createRoom(false)">STWÓRZ PUBLICZNY</button>
            <button onclick="createRoom(true)" style="background:#050;color:#0f0">STWÓRZ PRYWATNY</button>
            <div id="pub-list" style="max-height:120px; overflow-y:auto; margin:10px 0; font-size:12px; text-align: left;">Czekanie na serwer...</div>
            <input type="text" id="join-id" placeholder="KOD POKOJU">
            <button onclick="joinRoom(document.getElementById('join-id').value)" style="background:#0055ff; color:white;">DOŁĄCZ</button>
            <div id="status">Status: Łączenie...</div>
        </div>
    </div>

    <div id="hud">
        <div id="lvl-txt" style="font-size:24px; color:#0f0;">LEVEL: 1</div>
        <div id="key-status" style="color:#f00;">KLUCZ: BRAK</div>
    </div>

    <script type="importmap"> { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } } </script>

    <script type="module">
        import * as THREE from 'three';

        // JEŚLI WRZUCASZ NA GLITCH, WPISZ ADRES W IO("https://...")
        const socket = io(); 
        
        let scene, camera, renderer, currentId, hasKey = false, keyLockerIndex = -1;
        let yaw = 0, pitch = 0, lockers = [], others = {}, collidables = [], obstacles = [];
        let level = 1, velocityY = 0, isGrounded = true, isCrouching = false;
        const keys = {};

        socket.on('connect', () => document.getElementById('status').innerText = "Status: Online");
        socket.on('connect_error', () => document.getElementById('status').innerText = "Status: Budzenie serwera...");

        window.createRoom = (p) => socket.emit('create-room', p);
        window.joinRoom = (id) => socket.emit('join-room', id);

        socket.on('list-update', (list) => {
            const div = document.getElementById('pub-list');
            div.innerHTML = list.length ? '<b>LISTA GIER:</b>' : 'BRAK GIER PUBLICZNYCH';
            list.forEach(s => {
                div.innerHTML += `<div>${s.id} (${s.count}p) <button onclick="joinRoom('${s.id}')" style="width:auto; padding:2px 5px; margin-left:10px;">DOŁĄCZ</button></div>`;
            });
        });

        socket.on('joined', (data) => {
            currentId = data.id;
            keyLockerIndex = data.keyLocker;
            document.getElementById('menu').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            document.getElementById('crosshair').style.display = 'block';
            init();
        });

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            document.addEventListener('click', () => document.body.requestPointerLock());
            document.addEventListener('mousemove', (e) => {
                if(document.pointerLockElement === document.body) {
                    yaw -= e.movementX * 0.002;
                    pitch -= e.movementY * 0.002;
                    pitch = Math.max(-1.5, Math.min(1.5, pitch));
                }
            });

            generateLevel();
            animate();
        }

        function generateLevel() {
            lockers.forEach(l => scene.remove(l.parent));
            collidables.forEach(c => scene.remove(c));
            obstacles.forEach(o => scene.remove(o));
            lockers = []; collidables = []; obstacles = [];
            hasKey = false;
            document.getElementById('key-status').innerText = "KLUCZ: BRAK";
            document.getElementById('key-status').style.color = "#f00";
            camera.position.set(0, 1.6, 5);

            const depth = 20 + (level * 10);
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(20, depth), new THREE.MeshStandardMaterial({color: 0x111111}));
            floor.rotation.x = -Math.PI/2;
            floor.position.z = -depth/2 + 5;
            scene.add(floor);

            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            for(let z=0; z>-depth; z-=10) {
                let light = new THREE.PointLight(0x00ff00, 15, 12);
                light.position.set(0, 3, z);
                scene.add(light);
            }

            for(let i=0; i< (10 + level * 2); i++) {
                const group = new THREE.Group();
                const body = new THREE.Mesh(new THREE.BoxGeometry(1, 2.2, 0.8), new THREE.MeshStandardMaterial({color: 0x444444}));
                group.add(body);
                const door = new THREE.Mesh(new THREE.BoxGeometry(0.9, 2.1, 0.1), new THREE.MeshStandardMaterial({color: 0x222222}));
                door.position.set(0, 0, 0.45);
                door.userData = { index: i, opened: false };
                group.add(door);
                group.position.set(Math.random()*16-8, 1.1, -Math.random()*(depth-8));
                scene.add(group);
                lockers.push(door);
                collidables.push(body);
            }

            if(level > 1) {
                for(let i=0; i<level; i++) {
                    const laser = new THREE.Mesh(new THREE.BoxGeometry(10, 0.1, 0.1), new THREE.MeshBasicMaterial({color: 0xff0000}));
                    laser.position.set(Math.random()*10-5, 0.5 + Math.random()*1.5, -Math.random()*(depth-5));
                    scene.add(laser);
                    obstacles.push(laser);
                }
            }

            const exit = new THREE.Mesh(new THREE.BoxGeometry(4, 4, 0.2), new THREE.MeshStandardMaterial({color: 0x00ff00, wireframe: true}));
            exit.position.set(0, 2, -depth + 5);
            scene.add(exit);
        }

        window.onkeydown = (e) => {
            keys[e.code] = true;
            if(e.code === 'Space' && isGrounded && !isCrouching) { velocityY = 0.15; isGrounded = false; }
            if(e.code === 'KeyE') {
                const ray = new THREE.Raycaster();
                ray.setFromCamera(new THREE.Vector2(0,0), camera);
                const hits = ray.intersectObjects(lockers);
                if(hits.length > 0 && hits[0].distance < 3 && !hits[0].object.userData.opened) {
                    socket.emit('locker-opened', { roomId: currentId, index: hits[0].object.userData.index });
                }
            }
        };
        window.onkeyup = (e) => keys[e.code] = false;

        function animate() {
            requestAnimationFrame(animate);
            isCrouching = keys['ControlLeft'] || keys['ControlRight'];
            let targetH = isCrouching ? 0.8 : 1.6;
            camera.position.y = THREE.MathUtils.lerp(camera.position.y, targetH + (isGrounded ? 0 : velocityY), 0.2);

            const move = new THREE.Vector3();
            let speed = isCrouching ? 0.05 : 0.12;
            if(keys['KeyW']) move.z -= speed; if(keys['KeyS']) move.z += speed;
            if(keys['KeyA']) move.x -= speed; if(keys['KeyD']) move.x += speed;
            move.applyQuaternion(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), yaw));

            const nextP = camera.position.clone().add(move);
            let hit = false;
            collidables.forEach(c => { if(new THREE.Vector2(nextP.x, nextP.z).distanceTo(new THREE.Vector2(c.position.x, c.position.z)) < 1.1) hit = true; });
            if(Math.abs(nextP.x) > 9.5 || nextP.z > 9.5) hit = true;
            if(!hit) { camera.position.x = nextP.x; camera.position.z = nextP.z; }

            if(!isGrounded) {
                velocityY -= 0.005;
                camera.position.y += velocityY;
                if(camera.position.y <= targetH) { camera.position.y = targetH; velocityY = 0; isGrounded = true; }
            }

            obstacles.forEach(o => { if(camera.position.distanceTo(o.position) < 0.7) camera.position.set(0, 1.6, 5); });
            camera.rotation.set(pitch, yaw, 0, 'YXZ');

            const depth = 20 + (level * 10);
            if(hasKey && camera.position.z < (-depth + 7)) {
                socket.emit('win', currentId);
                hasKey = false;
            }

            const ray = new THREE.Raycaster();
            ray.setFromCamera(new THREE.Vector2(0,0), camera);
            const hits = ray.intersectObjects(lockers);
            document.getElementById('prompt').style.display = (hits.length > 0 && hits[0].distance < 3 && !hits[0].object.userData.opened) ? 'block' : 'none';

            renderer.render(scene, camera);
            if(currentId) socket.emit('move', {roomId: currentId, pos: camera.position.toArray(), rot: yaw});
        }

        socket.on('locker-state', (d) => {
            const door = lockers.find(l => l.userData.index === d.index);
            if(door) { door.rotation.y = Math.PI/2; door.position.x = 0.5; door.userData.opened = true; }
        });

        socket.on('key-found', () => {
            hasKey = true;
            document.getElementById('key-status').innerText = "KLUCZ: ZNALEZIONY!";
            document.getElementById('key-status').style.color = "#0f0";
        });

        socket.on('next-lvl', (d) => {
            level = d.level;
            document.getElementById('lvl-txt').innerText = "LEVEL: " + level;
            generateLevel();
        });

        socket.on('p-moved', (d) => {
            if(!others[d.id]) {
                others[d.id] = new THREE.Mesh(new THREE.CapsuleGeometry(0.3, 1), new THREE.MeshBasicMaterial({color: 0xff0000}));
                scene.add(others[d.id]);
            }
            others[d.id].position.set(d.pos[0], d.pos[1]-0.5, d.pos[2]);
        });

        socket.on('p-left', (id) => {
            if(others[id]) { scene.remove(others[id]); delete others[id]; }
        });
    </script>
</body>
</html>